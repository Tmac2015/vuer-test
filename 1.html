<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    
</body>
<script>
   let path= "1->5->3->5->1"
    
function isSymmetricalClosed(path) {
  /**
   * 此处写代码逻辑
   */
  var Larr = [];
  var Rarr = [];
  var nums = Math.floor(path.split("->").length / 2) ;
 
  if (!Math.floor(path.split("->").length) ) {return true}
  if (Math.floor(path.split("->").length % 2)) {
     
    path.split("->").map((item, index) => {
      if (index < nums) {
        Larr.push(item);
      } else if (index > nums){
        Rarr.push(item);
      }
    });
  } else {
    path.split("->").map((item, index) => {
      if (index < nums) {
        Larr.push(item);
      } else {
        Rarr.push(item);
      }
    });
  }
  
 
    return (Larr.toString() ==  Rarr.reverse().toString());
  
 
}
// console.log(isSymmetricalClosed(path))

var list = [1, 2, 3, 4] 
var delay = 5
function printList(list, delay) {
  /**
   * 此处写代码逻辑
   */
   list.map(function(item,index) {
       let indexs = index == (list.length - 1) ? 1 :index
        var x = setTimeout(function(  ) {  
            console.log(item)
        },delay*1000*index)
   })
}

// printList(list, delay)


const sourceTree = {
  id: "i1",
  value: 17,
  left: {
    id: "i3",
    value: 83,
    left: {
      id: "i4",
      value: 101
    },
    right: {
      id: "i9",
      value: 22
    }
  },
  right: {
    id: "i11",
    value: 26
  }
};
// 出参格式参考：
const maxNode = {
  id: "i4",
  value: 101
};

function findMaxNode(tree) {
  /**
   * 此处写代码逻辑
   */
  let maxNode = {id: "",
  value: -Infinity};
    
 
     
   function prenode(tree) {
        if (tree) {
            
    
        
            if (maxNode.value < tree.value) {
                maxNode.value = tree.value;
                maxNode.id = tree.id;
            
            }
            prenode(tree.left);
            prenode(tree.right);
        }
   }
   prenode(tree)

  return maxNode;
}
// console.log(findMaxNode(sourceTree))





// 实现一个日程安排函数，可以不断地登记行程安排，但不允许时间上出现三重重叠
// *三重重叠的含义为：有某个日期，同时被三次登记覆盖到
// *不考虑不同月份，并且假定每个月都是 31 天
// * book(1, 10)，两个数字入参的含义为预定 1~10 号
// * 函数返回 true 代表预定成功，返回 false 代表预定失败

// const mySchedule = new Calendar();
// mySchedule.book(1, 10) true
// mySchedule.book(8, 14) true (8-10 双重重叠)
// mySchedule.book(22, 30) true
// mySchedule.book(2, 9) false (8-9 三重重叠)
// mySchedule.book(18，20) true
// mySchedule.book(32，34) false (一个月只有 31 天)

class Calendar {
  /**
   * 此处写代码逻辑
   */
  constructor() {
    this.dateMap = {};
  }
  book(a, b) {
    var falge = true;
    if (a > 31 || b > 31 || a < 1 || b < 1) {
        falge =  false;
    }
    for (var i = a; i <= b; i++) {
      if (this.dateMap[i]) {
        this.dateMap[i]++;
      } else {
        this.dateMap[i] = 1;
      }
    }
    console.log( this.dateMap)
    var item;
   
    for (item in this.dateMap) {
    //   console.log(this.dateMap[item]);
      if (this.dateMap[item] > 2) {
        falge = false;
      }
    }

    if (!falge) {
        for (var i = a; i <= b; i++) {
      
        this.dateMap[i] -- ;
      
    }
    }
    return falge;
  
  }
}

/*******单测部分*******/
testResults = {};
try {
  const mySchedule = new Calendar();
  console.log(mySchedule.book(0, 0) === false);
  console.log(mySchedule.book(32, 35) === false);
  console.log(mySchedule.book(1, 10) === true);
  console.log(mySchedule.book(8, 14) === true);
  console.log(mySchedule.book(12, 16) === true);
  console.log(mySchedule.book(22, 30) === true);
  console.log(mySchedule.book(2, 9) === false);
  console.log(mySchedule.book(18, 20) === true);
  console.log(mySchedule.book(13, 17) === false);
  testResults[4] = "通过";
} catch {
  testResults[4] = "不通过";
}
console.log(testResults[4])
</script>
</html>